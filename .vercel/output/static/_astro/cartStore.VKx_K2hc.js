import{c as O}from"./createLucideIcon.V6CX3xPE.js";import{r as x,g as T,R as k}from"./index.Ba-IbuDT.js";/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ge=O("ShoppingCart",[["circle",{cx:"8",cy:"21",r:"1",key:"jimo8o"}],["circle",{cx:"19",cy:"21",r:"1",key:"13723u"}],["path",{d:"M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12",key:"9zh506"}]]),L={},w=e=>{let n;const r=new Set,s=(v,y)=>{const S=typeof v=="function"?v(n):v;if(!Object.is(S,n)){const m=n;n=y??(typeof S!="object"||S===null)?S:Object.assign({},n,S),r.forEach(p=>p(n,m))}},o=()=>n,d={setState:s,getState:o,getInitialState:()=>f,subscribe:v=>(r.add(v),()=>r.delete(v)),destroy:()=>{(L?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),r.clear()}},f=n=e(s,o,d);return d},P=e=>e?w(e):w;var D={exports:{}},$={},j={exports:{}},z={};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var b=x;function A(e,n){return e===n&&(e!==0||1/e===1/n)||e!==e&&n!==n}var J=typeof Object.is=="function"?Object.is:A,N=b.useState,U=b.useEffect,W=b.useLayoutEffect,M=b.useDebugValue;function q(e,n){var r=n(),s=N({inst:{value:r,getSnapshot:n}}),o=s[0].inst,t=s[1];return W(function(){o.value=r,o.getSnapshot=n,_(o)&&t({inst:o})},[e,r,n]),U(function(){return _(o)&&t({inst:o}),e(function(){_(o)&&t({inst:o})})},[e]),M(r),r}function _(e){var n=e.getSnapshot;e=e.value;try{var r=n();return!J(e,r)}catch{return!0}}function G(e,n){return n()}var B=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?G:q;z.useSyncExternalStore=b.useSyncExternalStore!==void 0?b.useSyncExternalStore:B;j.exports=z;var Q=j.exports;/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var I=x,K=Q;function X(e,n){return e===n&&(e!==0||1/e===1/n)||e!==e&&n!==n}var Y=typeof Object.is=="function"?Object.is:X,Z=K.useSyncExternalStore,V=I.useRef,ee=I.useEffect,te=I.useMemo,re=I.useDebugValue;$.useSyncExternalStoreWithSelector=function(e,n,r,s,o){var t=V(null);if(t.current===null){var u={hasValue:!1,value:null};t.current=u}else u=t.current;t=te(function(){function d(m){if(!f){if(f=!0,v=m,m=s(m),o!==void 0&&u.hasValue){var p=u.value;if(o(p,m))return y=p}return y=m}if(p=y,Y(v,m))return p;var l=s(m);return o!==void 0&&o(p,l)?(v=m,p):(v=m,y=l)}var f=!1,v,y,S=r===void 0?null:r;return[function(){return d(n())},S===null?void 0:function(){return d(S())}]},[n,r,s,o]);var c=Z(e,t[0],t[1]);return ee(function(){u.hasValue=!0,u.value=c},[c]),re(c),c};D.exports=$;var ne=D.exports;const oe=T(ne),C={},{useDebugValue:se}=k,{useSyncExternalStoreWithSelector:ae}=oe;let R=!1;const ie=e=>e;function ue(e,n=ie,r){(C?"production":void 0)!=="production"&&r&&!R&&(console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"),R=!0);const s=ae(e.subscribe,e.getState,e.getServerState||e.getInitialState,n,r);return se(s),s}const ce=e=>{(C?"production":void 0)!=="production"&&typeof e!="function"&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");const n=typeof e=="function"?P(e):e,r=(s,o)=>ue(n,s,o);return Object.assign(r,n),r},le=e=>ce,de={};function fe(e,n){let r;try{r=e()}catch{return}return{getItem:o=>{var t;const u=d=>d===null?null:JSON.parse(d,void 0),c=(t=r.getItem(o))!=null?t:null;return c instanceof Promise?c.then(u):u(c)},setItem:(o,t)=>r.setItem(o,JSON.stringify(t,void 0)),removeItem:o=>r.removeItem(o)}}const E=e=>n=>{try{const r=e(n);return r instanceof Promise?r:{then(s){return E(s)(r)},catch(s){return this}}}catch(r){return{then(s){return this},catch(s){return E(s)(r)}}}},me=(e,n)=>(r,s,o)=>{let t={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:i=>i,version:0,merge:(i,h)=>({...h,...i}),...n},u=!1;const c=new Set,d=new Set;let f;try{f=t.getStorage()}catch{}if(!f)return e((...i)=>{console.warn(`[zustand persist middleware] Unable to update item '${t.name}', the given storage is currently unavailable.`),r(...i)},s,o);const v=E(t.serialize),y=()=>{const i=t.partialize({...s()});let h;const a=v({state:i,version:t.version}).then(g=>f.setItem(t.name,g)).catch(g=>{h=g});if(h)throw h;return a},S=o.setState;o.setState=(i,h)=>{S(i,h),y()};const m=e((...i)=>{r(...i),y()},s,o);let p;const l=()=>{var i;if(!f)return;u=!1,c.forEach(a=>a(s()));const h=((i=t.onRehydrateStorage)==null?void 0:i.call(t,s()))||void 0;return E(f.getItem.bind(f))(t.name).then(a=>{if(a)return t.deserialize(a)}).then(a=>{if(a)if(typeof a.version=="number"&&a.version!==t.version){if(t.migrate)return t.migrate(a.state,a.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return a.state}).then(a=>{var g;return p=t.merge(a,(g=s())!=null?g:m),r(p,!0),y()}).then(()=>{h?.(p,void 0),u=!0,d.forEach(a=>a(p))}).catch(a=>{h?.(void 0,a)})};return o.persist={setOptions:i=>{t={...t,...i},i.getStorage&&(f=i.getStorage())},clearStorage:()=>{f?.removeItem(t.name)},getOptions:()=>t,rehydrate:()=>l(),hasHydrated:()=>u,onHydrate:i=>(c.add(i),()=>{c.delete(i)}),onFinishHydration:i=>(d.add(i),()=>{d.delete(i)})},l(),p||m},ve=(e,n)=>(r,s,o)=>{let t={storage:fe(()=>localStorage),partialize:l=>l,version:0,merge:(l,i)=>({...i,...l}),...n},u=!1;const c=new Set,d=new Set;let f=t.storage;if(!f)return e((...l)=>{console.warn(`[zustand persist middleware] Unable to update item '${t.name}', the given storage is currently unavailable.`),r(...l)},s,o);const v=()=>{const l=t.partialize({...s()});return f.setItem(t.name,{state:l,version:t.version})},y=o.setState;o.setState=(l,i)=>{y(l,i),v()};const S=e((...l)=>{r(...l),v()},s,o);o.getInitialState=()=>S;let m;const p=()=>{var l,i;if(!f)return;u=!1,c.forEach(a=>{var g;return a((g=s())!=null?g:S)});const h=((i=t.onRehydrateStorage)==null?void 0:i.call(t,(l=s())!=null?l:S))||void 0;return E(f.getItem.bind(f))(t.name).then(a=>{if(a)if(typeof a.version=="number"&&a.version!==t.version){if(t.migrate)return[!0,t.migrate(a.state,a.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,a.state];return[!1,void 0]}).then(a=>{var g;const[H,F]=a;if(m=t.merge(F,(g=s())!=null?g:S),r(m,!0),H)return v()}).then(()=>{h?.(m,void 0),m=s(),u=!0,d.forEach(a=>a(m))}).catch(a=>{h?.(void 0,a)})};return o.persist={setOptions:l=>{t={...t,...l},l.storage&&(f=l.storage)},clearStorage:()=>{f?.removeItem(t.name)},getOptions:()=>t,rehydrate:()=>p(),hasHydrated:()=>u,onHydrate:l=>(c.add(l),()=>{c.delete(l)}),onFinishHydration:l=>(d.add(l),()=>{d.delete(l)})},t.skipHydration||p(),m||S},pe=(e,n)=>"getStorage"in n||"serialize"in n||"deserialize"in n?((de?"production":void 0)!=="production"&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),me(e,n)):ve(e,n),he=pe,be=le()(he((e,n)=>({items:[],total:0,addItem:(r,s=1)=>{e(o=>{if(o.items.find(u=>u.product.id===r.id)){const u=o.items.map(d=>d.product.id===r.id?{...d,quantity:d.quantity+s}:d),c=u.reduce((d,f)=>d+f.product.price*f.quantity,0);return{items:u,total:c}}else{const u={product:r,quantity:s},c=[...o.items,u],d=c.reduce((f,v)=>f+v.product.price*v.quantity,0);return{items:c,total:d}}})},removeItem:r=>{e(s=>{const o=s.items.filter(u=>u.product.id!==r),t=o.reduce((u,c)=>u+c.product.price*c.quantity,0);return{items:o,total:t}})},updateQuantity:(r,s)=>{if(s<=0){n().removeItem(r);return}e(o=>{const t=o.items.map(c=>c.product.id===r?{...c,quantity:s}:c),u=t.reduce((c,d)=>c+d.product.price*d.quantity,0);return{items:t,total:u}})},clearCart:()=>{e({items:[],total:0})},getTotalItems:()=>n().items.reduce((r,s)=>r+s.quantity,0)}),{name:"cart-storage"}));export{ge as S,be as u};
